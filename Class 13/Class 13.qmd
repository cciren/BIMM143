---
title: "Class 13 RNA Seq Analysis with DESeq2"
author: "Irene Hsieh (A16197563)"
format: pdf
---

In today's class we will explore and analyze data from a published RNA-seq 
experiment where airway smooth muscle cells were treated with dexamethasone, 
a synthetic glucocorticoid steroid with anti-inflammatory effects 
(Himes et al. 2014).

## Data Import 

We have two input files, so called "count data" and "col data".


## Data Explore 

```{r}
# Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
head(counts)
```
```{r}
head(metadata)
```

> Q1. How many genes are in this dataset? 

```{r}
nrow(counts)
```

> Q2. How many ‘control’ cell lines do we have? 

```{r}
sum(metadata$dex == "control")
```

## Toy differntial gene expression

Time to do some analysis.

We have 4 control and 4 treated samples/experiments/columns

Make sure the matadata id column matches the columns in our count data.

```{r}
colnames(counts)
```
```{r}
metadata$id
```

```{r}
colnames(counts) == metadata$id
```

To check that all elements of a vector are TRUE we can use the `all()` function
```{r}
all(c(T,T,T,F))
```

```{r}
all(colnames(counts) == metadata$id)
```

To start I will calculate the `control.mean` and `treated.mean` values and 
compare them. 

- Identify and extract the `control` only columns
- Determine the mean value for each gene (i.e.row)
- do the same for `treated`.

> Q3. How would you make the above code in either approach more robust? Is there a function that could help here? 

```{r}
#Where does it tell me which columns are control?

control.inds <- metadata$dex == "control"
control.counts <- counts[, control.inds]
control.mean <- apply(control.counts,1, mean)
```

Now do the same for the treated samples to get `treated.mean`
> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treat.inds <- metadata$dex == "treated"
treat.counts <- counts[,treat.inds]
treated.mean <- apply (treat.counts,1,mean)
```
```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

Have a quick view of this data:
```{r}
plot(meancounts)
```
> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot? 

  geom_point() 
  
> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? 

```{r}
plot(meancounts, log= "xy")
```

I want to compare the treated and the control values here and we will use Fold 
change in log2 units to do this. log2(Treated/Control)

```{r}
log2fc <- log2(meancounts$treated.mean/meancounts$control.mean)
meancounts$log2fc <- log2fc 
```

```{r}
head(meancounts)
```

```{r}
sum(meancounts$log2fc > +2, na.rm = TRUE)
```

```{r}
to.rm.ind<- rowSums(meancounts[,1:2]==0)>0
mycounts <- meancounts [!to.rm.ind, ]
```


A doubling in the treated:
```{r}
log2(20/10)
```


```{r}
log2(5/10)
```


```{r}
log2(40/10)
```
A common rule of thumb cut off for calling a gene "differentially expressed" 
is a log2 fold-change value of either > +2 or <-2 for "up regulated" and "down 
regulated" respectively. 

we first need to remove zero count genes - as we cant say anything about these
genes anyway and their division of log values are messing things up (divided
by zero) or the -infinity log problem

> Q. How many genes do we have left that we can say something about 
(i.e. they don't have any zero counts)

```{r}
nrow(mycounts)
```

```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

arr.ind argument in the which() function identifies the indices where either the first or second column of meancounts is equal to zero.
We take the first column of the column to ensure that if there are duplicates occuring within the codes 

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```


> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
sum(up.ind)
```

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
sum(down.ind)
```

> Q10. Do you trust these results? Why or why not?

no, because the results may not be significant enough to validate the results. 
We are missing stats for differences significant

## DESeq analysis

Let's do this properly with the help of the DESeq2 package 

```{r}
#/ message: false 
library(DESeq2)
```

We have to use a specific data object for working with DESeq.

```{r}
dds<- DESeqDataSetFromMatrix(countData = counts,
                       colData = metadata,
                       design = ~dex)

```
The main analysis with the `DESeq()`function

```{r}
dds<- DESeq(dds)
```

To get the results out of our `dds` object we can use the DESeq function called
`results()`:

```{r}
res <- results(dds)
head(res)
```

# Volcano plot

A very common and useful summary results from figure from this type of analysis
is called a volcano plot - a plot of log2FC vs P-value. We use the `padj` the adjusted P-value for multiple testing.

```{r}
plot(res$log2FoldChange, res$padj)
```

```{r}
plot(res$log2FoldChange,-log(res$padj))
```

The smaller the log, the more significant the magnitude, the negative in front 
of the log flip the volcano back from upside down

```{r}
log(0.00005)
log(0.5)
```

Add some color and nice 

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```
```{r}
mycols <- rep("gray", nrow(res))

plot( res$log2FoldChange,  -log(res$padj), col = mycols)
abline(v=c(-2,+2))

mycols [res$log2FoldChange >2 ] <-  "blue"
mycols [res$log2FoldChange >0.02 ] <-  "grey"

plot(res$log2FoldChange, -log(res$padj), col=mycols)
abline(v=c(-2,+2))
```



```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

## Add Annotation data

```{r}
head(res)
```

We will use one of Bioconductor’s main annotation packages to help with mapping between various ID schemes. Here we load the AnnotationDbi package and the annotation data package for humans org.Hs.eg.db.

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",   # The format of our genenames
                     column="SYMBOL",     # The new format we want to add
                     multiVals="first")
```

```{r}
head(res)
```

> Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

## Pathway analysis

Now that I have added the necessary annotation data I can talk to different 
databases that use these IDs.
We will use the `gage` package to do geneset analysis(a.k.a. pathway analysis,
geneset enrichment, overlap analysis)

We will use KEGG first ()
```{r}
library(pathview)
library(gage)
library(gageData)

data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```
```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```
Run the analysis
```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
# Look at the first three down (less) pathways
head(keggres$less, 3)
```
I can now use the returned pathway IDs from KEGG as input to the `pathview` package to make pathway figures with our DEGs highlighted 

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```
![](hsa05310.pathview.png)






